<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üõ°Ô∏è Bullying Detector</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="BullyGuard">
    <link rel="manifest" href="manifest.json">
    
    <!-- Dynamic Icon Generation -->
    <script>
    // Generate simple icons if they don't exist
    document.addEventListener('DOMContentLoaded', function() {
        const generateIcon = (size) => {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, size, size);
            gradient.addColorStop(0, '#667eea');
            gradient.addColorStop(1, '#764ba2');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(size/2, size/8);
            ctx.lineTo(size/4, size/3);
            ctx.lineTo(size/4, size/1.5);
            ctx.lineTo(size/2, size/1.2);
            ctx.lineTo(size/1.33, size/1.5);
            ctx.lineTo(size/1.33, size/3);
            ctx.closePath();
            ctx.fill();
            return canvas.toDataURL('image/png');
        };
        const sizes = [72, 96, 128, 144, 152, 192, 384, 512];
        sizes.forEach(size => {
            const link = document.createElement('link');
            link.rel = 'icon';
            link.sizes = `${size}x${size}`;
            link.href = generateIcon(size);
            document.head.appendChild(link);
            if (size === 180) {
                const appleLink = document.createElement('link');
                appleLink.rel = 'apple-touch-icon';
                appleLink.sizes = `${size}x${size}`;
                appleLink.href = generateIcon(size);
                document.head.appendChild(appleLink);
            }
        });
        const themeMeta = document.createElement('meta');
        themeMeta.name = 'theme-color';
        themeMeta.content = '#667eea';
        document.head.appendChild(themeMeta);
    });
    </script>
    
    <style>
    /* styles unchanged from your original */
    </style>
</head>
<body>
    <div class="container">
        <!-- content unchanged from your original -->
    </div>

    <script>
        const ROBOFLOW_API_KEY = "1RuIGDSVW5gVOPaIq5I7";
        const MODEL_ENDPOINT = "https://detect.roboflow.com/bullying-detection-lixke-xxmrf/1";

        const fileInputCamera = document.getElementById('file-input-camera');
        const fileInputGallery = document.getElementById('file-input-gallery');
        const loading = document.getElementById('loading');
        const results = document.getElementById('results');
        const resultsContent = document.getElementById('results-content');
        const installBtn = document.getElementById('installBtn');
        const uploadArea = document.getElementById('upload-area');

        fileInputCamera.addEventListener('change', handleFileSelect);
        fileInputGallery.addEventListener('change', handleFileSelect);

        function takePhoto() { fileInputCamera.click(); }
        function openGallery() { fileInputGallery.click(); }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                handleFile(file);
                event.target.value = '';
            }
        }

        function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file');
                return;
            }
            const reader = new FileReader();
            reader.onload = function(e) { showPreview(e.target.result); };
            reader.readAsDataURL(file);
            analyzeImage(file);
        }

        function showPreview(imageSrc) {
            const existingPreview = document.querySelector('.preview-image');
            if (existingPreview) existingPreview.remove();
            const img = document.createElement('img');
            img.src = imageSrc;
            img.className = 'preview-image';
            img.alt = 'Selected image';
            uploadArea.appendChild(img);
        }

        async function analyzeImage(file) {
            loading.style.display = 'block';
            results.style.display = 'none';
            try {
                const img = await createImageBitmap(file);
                const canvas = document.createElement("canvas");
                const ctx = canvas.getContext("2d");
                const maxSize = 1024;
                let { width, height } = img;
                if (width > height) {
                    if (width > maxSize) { height = Math.round(height * (maxSize / width)); width = maxSize; }
                } else {
                    if (height > maxSize) { width = Math.round(width * (maxSize / height)); height = maxSize; }
                }
                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(img, 0, 0, width, height);
                const blob = await new Promise(resolve => canvas.toBlob(resolve, "image/jpeg", 0.8));
                const formData = new FormData();
                formData.append('file', blob, "photo.jpg");
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000);
                const response = await fetch(`${MODEL_ENDPOINT}?api_key=${ROBOFLOW_API_KEY}&confidence=40&overlap=30`, {
                    method: 'POST',
                    body: formData,
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                if (!response.ok) throw new Error(`API request failed: ${response.status}`);
                const result = await response.json();
                displayResults(result);
            } catch (error) {
                console.error('Error:', error);
                if (error.name === 'AbortError') {
                    displayError('Request timeout. Please check your internet connection and try again.');
                } else {
                    displayError('Analysis failed. Please try again.');
                }
            } finally {
                loading.style.display = 'none';
            }
        }

        // displayResults, displayError, PWA install, service worker registration unchanged
    </script>
</body>
</html>
